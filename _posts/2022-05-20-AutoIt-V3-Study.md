---
title: "즐거운 AutoIt 코딩 (교재)"
excerpt: ""
categories: "blog"
toc: true
date: 2022-05-20
last-modified-at: 2022-05-28
---



# 즐거운 AutoIt 코딩 (교재)



## 1. 오토잇 소개

오토잇은 이름 그대로 마이크로소프트 윈도우즈 운영체제에서 무엇인가를 자동화하는 데에 강점이 있는 프로그래밍 언어입니다. 배우기 쉬운 베이직 문법으로 되어 있으며, 자동화 이외에도 다양한 프로그램을 만들 수 있습니다. 무엇보다도 키보드, 마우스 시뮬레이션 기능을 아주 쉽게 사용할 수 있습니다. 이 특징 덕택에 오토잇 문법을 모르는 시각장애인도 유용한 자동화 프로그램을 쉽게 만들 수 있습니다. 뿐만 아니라 오토잇은 GUI도 쉽게  구현할 수 있습니다. 물론 복잡한 GUI를 만들기에 부족한 점도 있고 스크린리더 반응 속도도 조금 늦다는 단점도 있습니다만, 압도적으로 쉽게 GUI를 구현할 수 있다는 장점은 아무리 칭찬해도 지나치지 않습니다.

오토잇은 스크립트 언어이면서도 컴파일을 통해 단독 실행 파일을 만들 수 있습니다. 가끔 백신 프로그램이 바이러스로 오진하기 합니다만 그건 다른 프로그래밍 언어들도 마찬가지입니다. 모두 마이크로소프트의 디지털 서명을 받지 않았기 때문입니다. 보통 스크립트 언어들을 단독 실행 파일로 만들면 그 크기가 상당히 큽니다. 단 한줄의 print 함수만 동작하는 데에도 10MB가 넘기도 하고 때론 수 십MB를 넘기도 합니다. 하지만 오토잇은 1MB를 넘지 않습니다. 아주 경제적이지요.

오토잇에 대한 소개는 이정도에서 마치고 오토잇 개발 환경을 만들어 봅시다. 말이 좋아 개발 환경이지 그냥 오토잇 개발 도구를 다운로드 받아서 설치하는 걸로 끝입니다.



## 2. 오토잇 설치

오토잇은 <https://www.autoitscript.com>에서 다운로드 할 수 있습니다. 귀찮은 분들은 아래 링크에서 곧바로 다운로드 받을 수 있습니다.

<https://www.autoitscript.com/cgi-bin/getfile.pl?autoit3/autoit-v3-setup.zip>

2022년 5월 현재 최신 버전은 3.3.16.0이며, 22년 3월 6일에 업데이트 되었습니다. zip 압축을 해제하고 설치 프로그램을 실행하세요. 설치 옵션은 변경할 필요가 없습니다. 디폴트로 설치하세요. 

이제 오토잇으로 코딩할 준비가 끝났습니다.



## 3. 오토잇 코드 편집기

오토잇을 설치하면 오토잇 언어에 최적화된 SciTe 편집기가 함께 설치됩니다. 오토잇 전용 SciTe 편집기는 센스리더가 제대로 지원해 주지 못합니다. 이 편집기를 사용하고자 한다면 센스리더 대신 NVDA를 사용하세요. 하지만 NVDA도 자동완성 목록을 읽어 주지 못합니다. 

소스코드의 인코딩은 File' 메뉴에서 'encoding'의 하위 메뉴 'UTF-8'을 선택하세요.

센스리더 사용자도 걱정마세요. 메모장으로 편집하시고 파일 확장자를 'au3'으로 바꾸세요. 그리고 윈도우 탐색기에서 팝업 키를 누르면 곧바로 소스 파일을 실행하거나 컴파일할 수 있는 컨텍스트 메뉴가 열립니다. 참 쉽지요!

확장자를 .au3으로 바꾸는 것도 귀찮다면 파일 탐색기에서 팝업 메뉴를 열고 '새로 만들기'에서 곧바로 오토잇 소스 코드 파일을 생성할 수 있습니다.



## 4. 첫번째 오토잇 프로그램 "Hello, World"

대부분의 프로그래밍 언어의 첫번째 예제는 바로 "안녕, 세계야"를 화면에 표시하는 것입니다. 오토잇도 예외가 아닙니다. 편집기에 다음과 같이 입력해 보세요.

### 01_hello.au3

```autoit

MsgBox(0, "첫번째 프로그램", "안녕, 세계야")

```

SciTe에서는 소스 코드를 저장한 후 F5로 실행 결과를 볼 수 있습니다. 메모장이라면 윈도우 탐색기에서 팝업 키를 누르고 Run Script 메뉴를 선택하시면 hello.au3이 실행됩니다.

보통 대다수의 프로그래밍 언어는 콘솔 화면에 "안녕, 세계야"가 출력될 것입니다. 오토잇은 처음부터 콘솔 화면이 아니라 GUI 방식으로 결과를 보여 줍니다.

이 코드를 설명합니다.

MsgBox는 메시지상자를 화면에 표시하는 함수입니다. 이 메시지상자가 표시되는 동안 프로그램은 일시 정지됩니다. 이 상자가 닫히면 다음 코드가 실행됩니다.

MsgBox에서 대소 문자를 구별할 필요가 없습니다. msgbox나 MsgBox나 MSGBOX나 msGboX는 모두 같습니다. 귀로 듣기 편한 방식으로 입력하셔도 됩니다.

오토잇은 베이직 스타일의 문법을 가지고 있습니다. 베이직류 언어들의 문법은 대소문자를 엄격하게 구별하지 않습니다. 

대소문자를 자유롭게 사용하는 것도 좋습니다만, 일반적인 관습에 따르는 것도 좋습니다. 일반적인 관습은 간단합니다.

단어의 시작 글자를 대문자로 씁니다. 단어가 축약된 경우에는 세글 자 이상인 경우 첫글자만 대문자로 쓰고 두 글자인 경우에는 두 글자 모두 대문자로 적는다는 관습이 있습니다만 일단은 단어의 첫 글자만 대문자로 쓴다는 것에만 주의합시다.

MsgBox는 함수입니다. 함수는 어떠한 기능을 실행하기 위한 장치입니다. 함수를 실행하려면 뒤에 반드시 "("와 ")"가 필요합니다. 괄호 사이에는 장치에 투입될 재료들을 적어 줍니다.

라면 공장을 생각해 봅시다. 라면을 만드려면 밀가루, 고추가루, 소금 등등이 필요할 겁니다. 이러한 재료를 넣으면 기계가 철컹 철컹 돌아가면서 봉지에 담긴 라면이 탁 나오는 겁니다.

위 예제에서 괄호 속에 든 0, "첫번째 프로그램", "안녕, 세계야"는 기계에 넣을 재료들입니다.

이것을 인수(argument)라 부릅니다. 일단은 그냥 재료라고 이해하고 넘어 갑시다.

첫번째 재료: 0

MsgBox의 첫번째 재료는 숫자 0입니다. 이 숫자는 메시지상자의 스타일을 결정합니다.

0은 '확인' 버튼을 가진 메시지상자를 만듭니다. 이 숫자를 1로 변경해 보겠습니다. 

### 02_hello2.au3

```autoit

MsgBox(1, "첫번째 프로그램", "안녕, 세계야")

```

실행 결과를 보시면 '확인' 버튼과 '취소' 버튼을 가진 메시지상자가 나타날 것입니다. ESC를 누르면 '취소' 버튼을 누른 것과 같은 동작을 합니다.

이 숫자를 2로 변경하면 '중단', '다시 시도', '무시' 버튼을 가진 메시지상자가 나타납니다. 자세한 건 뒤에 다시 다루겠습니다. 급한 분들은 오토잇 메뉴얼을 찾아 보세요.

첫번째 재료 숫자를 변경함으로써 메시지상자의 스타일을 바꿀 수 있고 단순한 메시지 표시 뿐만 아니라 우리들의 선택을 프로그램에 반영할 수 있습니다.

괄호 내의 ","는 재료와 재료를 구별하기 위해 사용합니다. 만약 함수의 재료가 하나라면 쉼표를 쓸 필요가 없습니다. 재료가 두 개 이상일 때 그것들을 구별하기 위해 쉼표를 사용합니다.

두 번째 재료 "첫번째 프로그램" 처럼 쿼테이션이나 어퍼스트로피로 시작하고 끝나는 것들을 통칭 문자열이라고 부릅니다. 문자가 하나일 수도 있고 여러 개일 수도 있는데 문자 여러 개가 줄줄이 붙어 한 줄로 나란히 있으니 "열"이라 부르는 것입니다. 영어로는 string이라 부릅니다.

그렇다면 숫자 0과 문자열 "0"에는 어떤 차이가 있을까요? 이제 프로그램을 또 수정해 봅시다. 첫번째 재료를 "0"으로 바꾸고 hello3.au3으로 저장한 후 실행해 봅니다.

### 03_hello3.au3

```autoit

MsgBox("0", "첫번째 프로그램", "안녕, 세계야")

```

실행 결과는 hello.au3 파일과 똑같습니다. 어찌된 일일까요?

일반적으로 프로그래밍 언어에서  숫자 0과 문자열 "0"은 완전히 다릅니다. 숫자는 덧셈을 할 수 있지만 문자열은 덧셈을 할 수 없는 것이 원칙입니다. 하지만 오토잇은 다릅니다. 숫자를 때론 문자열로 바꿔 주고 숫자로 이루어진 문자열은 알아서 숫자로 바꿔 줍니다. 오토잇 메뉴얼에 의하면 오토잇에는 단 하나의 데이터 타입이 있다고 합니다. 그것이 바로 베리언트(variant) 타입입니다. 베리언트 타입은 무엇이든 될 수 있습니다. 웬만한 건 오토잇이 알아서 해 줍니다. 다만 사용자가 문자열로 쓸 것인지 숫자로 쓸 것인지 확실하게 정해 주어야할 때가 종종 있습니다.

hello.au3 파일의 두번째 줄에 다음과 같은 내용을 추가해 봅시다.

MsgBox(0, "숫자 계산", 12+34)

34라는 결과를 볼 수 있습니다. 다른 언어들에서는 숫자를 곧바로 문자열처럼 출력했기 때문에 에러가 발생할 가능성이 높습니다. 하지만 오토잇은 알아서 숫자 결과를 문자열로 바꿔 주었습니다. 이제 세번 째 줄에 다음과 같이 추가해 봅시다.

MsgBox(0, "문자열 결합", 12 & 34)

실행 결과는 흥미롭게도 1234입니다.

오토잇에서 "+"는 숫자의 덧셈을 의미합니다. "&"는 문자열을 결합할 때 사용합니다. 오토잇은 "+"를 만나면 양쪽을 모두 숫자로 바꿔 계산하고, "&"를 만나면 숫자를 문자열로 바꿔서 결합합니다.

MsgBox의 두 번째 재료는 문자열로 메시지상자의 제목(caption)이 됩니다. 세번째 재료는 메시지상자 본문이 됩니다.



## 5. 두번째 프로그램

오토잇 메뉴얼에 나오는 두번째 예제는 간단한 자동화입니다. 메모장을 실행하고 메모장에 특정 문장을 쓰고, 메모장을 닫습니다. 메모장을 닫을 때 "변경 내용 저장" 대화상자가 나타날 것입니다. 이때 "저장 안 함"을 누르도록 하겠습니다. 다음은 소스 코드입니다. 

### 04_notepad.au3

```autoit

Run("notepad.exe")
WinWaitActive("제목 없음 - Windows 메모장")
Send("여러분 안녕하세요. 저는 메모장입니다.")
Sleep(3000)
WinClose("*제목 없음 - Windows 메모장")
Send("!n")

```

소스 코드를 해설합니다.

Run("notepad.exe")

Run 함수는 컴퓨터 내에 있는 실행 파일을 실행시키는 함수입니다. "notepad.exe"는 메모장의 실행 파일입니다. 

WinWaitActive("제목 없음 - Windows 메모장")

WinWaitActive함수는 특정 대화상자가 화면에 활성화되기를 기다리는 함수입니다. "제목 없음 - Windows 메모장"이란 제목을 가진 대화상자가 나타날 때까지 오토잇은 대기상태에 들어 갑니다. 즉 메모장이 실행되기를 기다리는 거지요. 메모장 프로그램이 활성화 되면 다음 줄이 실행됩니다. 윈도우즈11의 경우 메모장 제목줄에 "Windows" 단어가 없습니다.

Send("여러분 안녕하세요. 저는 메모장입니다.")

Send 함수는 문자열을 활성화된 프로그램에게 전달하는 함수입니다. 우리가 꼭 키보드를 타이핑한 것처럼 말입니다. Send 함수는 키보드 시뮬레이션 기능인 셈입니다. 이 줄이 실행되면 메모장 편집창에 "여러분 안녕하세요. 저는 메모장입니다."라는 텍스트가 씌여집니다.

Sleep(3000)

Sleep은 프로그램 실행을 중지하고 대기하는 함수입니다. 이 함수의 재료는 시간입니다. 시간 단위는 1000분의 1초입니다. 통상 밀리초(ms)라 불리는 것입니다.

WinClose("*제목 없음 - Windows 메모장")

WinClose는 특정 대화상자를 닫기 위한 함수입니다. 그런데 "제목 없음" 앞에 "*"가 붙습니다. 메모장이 활성화 되면 제목 처음에 "*"를 추가하기 때문입니다.

Send("!n")

메모장을 종료할 때 메모장 편집창의 내용이 수정되었다면 "변경 사항 저장"을 묻는 대화상자가 나타납니다. 이때 우리는 "저장 안 함" 버튼을 누르거나 단축키로 Alt+n을 누를 겁니다. Send 함수의 재료에 알트 키도 넣을 수 있습니다. 바로 "!"입니다. "!"는 알트키를 의미합니다. "!n"이란 Alt+n 단축키와 같습니다. 이 줄이 실행되면 메모장이 "변경 내용 저장" 없이 종료되며 동시에 04_notepad.au3 프로그램도 종료하게 됩니다.

WinWaitActive를 꼭 사용할 필요는 없습니다. 이 줄 대신 그냥 Send(3000) 누르셔도 대체로 동일한 결과가 나옵니다. 메모장은 대체로 3초 안에 실행을 마치기 때문입니다.

WinClose 함수도 꼭 사용할 필요가 없습니다. Send("!{f4}")로 대체할 수 있습니다. 앞서 말씀 드린 것처럼 "!"는 Alt 키입니다. "{f4}"는 여러분이 기대한 바로 그 F4 키입니다. 즉 이 줄은 Alt+F4를 눌러 메모장을 종료하라는 것입니다.

그렇다면 왜 WinWaitActive, WinClose 같은 함수를 사용할까요? 그건 정확히 메모장 단 하나에만 프로그램을 동작시키기 위함입니다. 컴퓨터는 사용자의 의사와 관계 없이 특정한 대화상자를 활성화시킬 수 있습니다. 이럴 때 notepad.au3 파일이 실행되면 문자열이 엉뚱한 곳에 전달된다든지 예기치 못하게 특정 프로그램을 종료시킬 수도 있습니다. 따라서 에러를 줄이기 위해 WinWaitActive 같은 함수를 사용하는 것입니다.

한번 만들어 봅시다.

윈도우 디펜더의 실시간 감시 기능을 켜거나 끄고 싶습니다. Send, Sleep 함수만으로 실시간 검사 기능을 토글해 보세요.



## 6. 세번째 프로그램

우리가 만들 세번째 오토잇 프로그램은 바로 계산기입니다. 소스코드는 다음과 같습니다.

###  05_calc.au3

```autoit

$Result = 0
While 1
   $s = InputBox("계산기", "수식 입력", $Result)
   If Not $s Then Exit
	  $Result = Execute($s)
   WEnd

```

여섯 줄로 간단하게 계산기를 구현해 보았습니다. 코드에 대해 설명해 보겠습니다.

$Result = 0

$Result처럼 앞에 "$"가 붙은 것들을 변수(variables)라 부릅니다. 오토잇에서 변수를 만들 때에는 반드시 앞에 "$"를 붙여야 합니다. 그렇지 않으면 에러가 발생합니다. 

변수는 반찬통에 붙이는 점자 라벨과 비슷합니다. 냉장고에 든 반찬통에 무엇이 들어 있는지 시각장애인들은 쉽게 알아내기 어렵습니다. 이럴 때 점자 라벨을 붙이면 편리합니다. 오토잇도 마찬가지입니다. 코딩을 할 때 많은 데이터를 다루게 되는데 이때 각각의 데이터를 쉽게 기억하고 사용하기 위해 변수가 필요합니다.

오토잇에서 변수는 어떤 데이터에도 자유롭게 붙일 수 있습니다. 같은 변수를 다른 종류의 데이터에 붙여도 괜찮습니다. 이것을 동적 타이핑(dynamic typing)이라 부릅니다. 동적 타이핑 방식의 언어들은 초보자들 입장에서 코딩하기에는 편리하지만 프로그램의 연산 속도를 떨어 뜨리는 주범이기도 합니다. 대다수의 스크립트 언어들이 컴파일 언어들에 비해 속도가 현저하게 느린 이유가 바로 이것입니다.

* 대입 연산자

수학에서 "="은 "같다"는 의미입니다. 그런데 코딩에서는 의미가 조금 다릅니다. 오른쪽에 있는 숫자 0을 왼쪽에 있는 $Result 변수에 "대입"한다는 의미입니다. 거칠게 표현하자면 $Result란 라벨이 붙은 반찬통에 숫자 0을 집어 넣는 것으로 이해하셔도 좋습니다.

"="을 대입 연산자라 부르는데요. 바로 오른쪽에 있는 것을 왼쪽에 넣는다는 의미일 뿐입니다. 이런 코드가 있다고 생각해 봅시다.

$Result = $Result + 1

수학으로 치면 이런 식은 에러입니다. $Result에는 0이 들어가 있지요. 

0 = 0 + 1

0=1

그런데 코딩에서는 문제가 되지 않습니다. 먼저 오른쪽을 계산합니다. 이 결과를 다시 $Result에 대입합니다. 결과는 $Result에 1이 들어갑니다.

$Result라는 변수를 만든 이유는 여기에 계산 결과를 담아서 화면에 표시하기 위해서입니다. 자세한 건 아래에서 다시 설명하겠습니다.

While 1

While은 반복 작업을 시키기 위해서 사용합니다.

While과 짝을 이루는 것은 WEnd입니다. While과 WEnd 사이에 있는 코드를 계속 반복 실행합니다. 계산기를 사용할 때 딱 한번만 사용하고 종료시키지 않습니다. 여러 번 계산할 수도 있고 앞서 계산한 결과에 추가적인 계산을 이어갈 수도 있습니다. 

그런데 무한하게 코드가 반복되는 것도 비효율적입니다. While 뒤에 조건을 달아서 반복을 제한할 수 있습니다. 그런데 While 뒤에 1을 붙인 이유는 무한 반복을 시키기 위해서입니다.

While로 코드를 반복 실행할 때 매번 While 뒤에 있는 것으로 참과 거짓을 구별합니다. 만약 참이면 계속 반복하고 거짓이면 반복을 중지하고 W
End 다음에 있는 코드를 실행합니다. 

참과 거짓을 오토잇에서는 True/False로 표현합니다. 이것들은 진리값 타입의 데이터이며 영어로는 불리언(Boolean)이라고 부릅니다. 이 불리언 타입은 숫자 타입, 문자열 타입과 함께 가장 기초적인 데이터 타입 중 하나입니다. 이런 데이터가 있다는 것을 꼭 기억하세요.

참과 거짓을 구별할 때 0은 항상 거짓이며 0을 제외한 숫자는 모두 참입니다. 무엇인가가 있으면 참, 아무 것도 없으면 거짓인 셈입니다. 문자열의 경우 "" 처럼 아무 내용도 없으면 거짓, 무엇이라도 들어 있으면 참입니다.

   $s = InputBox("계산기", "수식 입력", $Result)

InputBox는 MsgBox와 반대의 역할을 합니다. MsgBox는 사용자에게 무엇인가를 알려 주기 위한 기능이라면 InputBox는 사용자가 컴퓨터에게 무엇인가를 알려줄 때 사용합니다. 계산기의 경우 계산 수식을 컴퓨터에게 전달할 필요가 있습니다. 이럴 때에 InputBox를 사용합니다.

InputBox 함수에는 많은 재료들을 넣을 수 있습니다. 이번에는 그중에서 가장 중요한 맨 앞 세 개만 넣어 보겠습니다.

첫번째 "계산기"란 문자열은 InputBox의 제목에 해당합니다. 두번째 '수식 입력"은 편집창의 역할을 설명하는 텍스트입니다. 세번째 $Result는 기본값입니다. InputBox가 화면에 표시될 때 편집창이 하나 나타나는데 그 편집창에 들어갈 기본 내용입니다. While로 계산이 반복될 때 $Result 변수에 담긴 계산 결과 값이 편집창에 표시될 예정입니다. 

   If Not $s Then Exit

If로 시작하는 문장을 조건문이라고 합니다. If와 Then 사이에 들어 있는 내용이 참이면 Then 다음의 코드를 실행하고 거짓이면 If 다음 코드로 건너 뜁니다.

$s 변수에는 InputBox의 실행 결과가 들어 갑니다. InputBox의 편집창에 "1+2"라 적으면 $s에는 "1+2"가 들어 갑니다. 만약 아무 것도 입력하지 않고 엔터 키를 치거나 ESC를 누르는 경우 $s에는 텅빈 문자열이 들어 갑니다. 텅빈 문자열은 ""으로 표현할 수 있습니다.

Not은 참을 거짓으로 바꾸고 거짓을 참으로 바꾸는 역할을 합니다.

만약 $s에 수식이 들어 있다면 $s는 참이 되고 Not 때문에 다시 거짓이 됩니다. $s에 수식이 들어 있다면 If 조건문은 실행되지 않습니다. 만약 $s가 텅빈 문자열이라면 거짓이 되고 다시 Not 때문에 참이 될 겁니다. 그러므로 Then 다음에 있는 Exit가 실행됩니다.

Exit

Exit는 이름 그 대로 프로그램을 종료하라는 명령어입니다.

	  $Result = Execute($s)

$s에 수식이 담겨 있다면 그 수식을 계산하게 하는 코드입니다.

Execute 함수에는 재료가 하나 들어 갑니다. 그 재료는 문자열입니다. Execute는 이 문자열을 오토잇 코드라 판단하고 그것을 계산합니다. 수식이 들어 있다면 그 수식을 계산해서 결과 값을 $Result에 넣어 줍니다.

   WEnd

WEnd는 앞서 설명했듯 While과 짝을 이룹니다. 코드에서 WEnd를 만나면 While로 올라가서 다시 실행됩니다.

한번 calc.au3 파일을 실행해 보세요. 그리고 계산기처럼 수식을 넣어 보세요.

덧셈: +
뺄셈: -
곱셈: *
나눗셈: /



## 7. 네 번째 프로그램

우리가 만들 네번째 프로그램은 메모장 넋두리 프로그램입니다. 우리 시각장애인들은 그동안 메모장을 너무 혹사시켰습니다. 메모장이 힘들만 합니다. 메모장이 활성화 될 때마다 메모장은 10초에 한번씩 이렇게 말합니다. 

"왜 나만 써? 워드패드도 있잖아."

### 06_tts.au3

```autoit

; 06_tts.au3

$oTTS = ObjCreate("Sapi.SpVoice")
While 1
	$sTitle = WinGetTitle("[active]")
	If StringRight($sTitle, 3) == "메모장" Then
		Sleep(5000)
		$oTTS.Speak("왜 나만 써? 워드패드도 있잖아!")
	Else
		Sleep(100)
	EndIf
WEnd

```

이 프로그램을 실행해 보세요. 정말 메모장의 고단함이 느껴지지 않으십니까?

먼저 이 프로그램을 종료하는 법을 설명해 드리겠습니다. 오토잇 프로그램이 실행될 때 프로그램을 종료시킬 수 잇는 아이콘이 시스템 트레이 영역에 들어 갑니다. 시스템 트레이 영역에서 오토잇 아이콘에서 팝업키를 누르면 종료 메뉴가 나타납니다. 여기에서 종료시키세요.

만약 소스코드 최상단에 다음 문장을 추가하면 트레이 영역에 아이콘이 생성되지 않습니다.

#NoTrayIcon 

이 한 줄을 추가하면 tts.au3 프로그램은 쉽게 종료되지 않습니다. 작업관리자를 열어서 autoit3.exe 프로세스를 찾아 종료해야 합니다. 

오토잇은 숫자, 문자열 같은 종류 뿐만아니라 객체 타입의 데이터도 사용할 수 있습니다. 객체란 속성과 기능(함수)을 모두 가진 데이터입니다. 오토잇에서는 마이크로소프트에서 규정한 COM 객체만을 다룰 수 있습니다. COM으로 인해 오토잇은 윈도우 내의 다른 구성요소들 이를테면 윈도우에 설치된 TTS, 엑셀 등등을 다룰 수 있습니다. 

위 예제에서 ObjCreate 함수는 윈도우즈 운영체제에 기본적으로 설치되어 있는 TTS를 가져왔습니다. 그중에서도 S-API 버전입니다. $oTTS에는 SAPI 엔진이 들어갑니다. 이 객체에 들어 있는 .Speak 함수를 사용하면 메모장이 넋두리를 말할 수 있게 됩니다. 센스리더의 음성엔진 객체를 사용하려면 ObjCreate("SenseReader.Application")을 사용하세요.

WinGetTitle은 특정 윈도우의 제목을 가져옵니다. WinGetTitle의 첫번째 재료 "[active]"는 현재 활성화되어 있는 윈도우를 가리킵니다. 현재 활성화된 윈도우의 제목을 $sTitle에 저장합니다.

StringRight는 전체 문자열에서 부분 문자열을 가져오는데 오른쪽에서부터 문자열을 끊어서 가져옵니다. 두번째 재료 3은 오른쪽에서부터 3글자를 의미합니다. 

메모장이 활성화되어 있다면 $sTitle에는 "제목 없음 - Windows 메모장"이 저장될 것입니다. StringRight로 오른쪽에서 3글자 즉 "메모장"을 떼어 냅니다. 그 결과가 "메모장"이라면 현재 메모장이 활성화되어 있다는 것을 알 수 있습니다. 메모장에 어떤 파일이 열려 있더라도 제목의 마지막에는 "메모장" 세 글자가 들어가니까요.

메모장이 활성화 되어 있다면 If 아래쪽 코드가 동작합니다. 먼저 5초간 대기하고 그 다음 넋두리를 시작합니다. 넋두리를 끝내면 Else 아래의 코드를 건너 뛰고 다시 While 1로 올라가서 다음 반복을 시작합니다.

만약 현재 활성화된 윈도우가 메모장이 아니라면 Else 아래의 코드가 동작합니다. 0.1초간 대기했다가 다시 While 1로 다음 반복을 합니다. 0.1초의 대기시간을 두지 않으면 오토잇이 불필요하게 컴퓨터의 자원을 소모하게 됩니다.

이제 메모장의 넋두리를 들어 봅시다. 

자! 이것으로 오토잇의 소개를 마치겠습니다.



## 8. 변수 이름 짓기

변수 이름은 $로 시작해야 합니다. $ 뒤에 이어서 문자, 숫자, 언더바(_)를 하나 이상 사용할 수 있습니다. 변수 이름도 함수 이름처럼 대소문자를 가리지 않습니다. 예를 들어 $name과 $Name과  $NAME은 모두 같은 변수입니다.

변수 이름을 지을 때에도 규칙을 정해서 사용하면 좋습니다. 오토잇은 "헝가리언 표기법"을 따른다고 합니다. 먼저 $ 다음에 데이터 타입을 알 수 있도록 소문자로 시작하고 그 다음에 실질적인 변수의 이름을 적습니다. 데이터 타입과 예제는 다음과 같습니다.

$a: 배열, $aArray[0]

$b: 진리값, $bBool = True

$f: 소수점 숫자, $fFloat = 123.45

$i: 소수점 없는 숫자, $iInteger = 123

$m: 맵 데이터, $mMap[]

$n: 모든 숫자

$o: 객체 타입, $oTTS

$s: 문자열, $sName = "AutoIt"

$v: 베리언트 타입

변수 뒤에는 변수의 이름을 적습니다. 만약 사람 이름이라면 $sName이라는 식입니다. 이때 Name의 첫 글자는 대문자로 사용합니다. 함수명을 적을 때와 같은 규칙을 사용하는 게 좋습니다.



## 9. 변수 선언하기

변수는 Local, Global이라는 키워드와 함께 선언합니다. Dim이라는 키워드로 선언할 수도 있는데 추천하는 방식은 아닙니다. 

Local $sName

한 줄에 여러 변수를 선언할 수도 있습니다.

Global $sName, $sAddress, $iAge

변수 선언과 동시에 데이터를 변수에 저장할 수 있습니다. 이것을 변수 초기화라고 합니다.

Local $sName = "AutoIt"

변수를 초기화할 때 Local, Global, Dim 키워드를 생략할 수도 있습니다만, 추천하지는 않습니다. 명시적으로 Local, Global 키워드를 사용하세요. 무엇보다도 Global은 꼭 사용하세요.

$iAge = 15

키워드 없이 변수가 초기화 된다면 자동으로 Dim 키워드가 붙은 것과 같습니다.



## 10. 상수 선언

상수(Constants)는 한번 저장된 데이터를 변경할 수 없는 데이터 타입입니다. 상수는 Const 키워드로 선언합니다. 상수는 $뒤에 e를 붙여서 타입을 표시합니다. e는 Enum의 첫 글자입니다.

Const $ePi = 3.141592

Enum 키워드를 써서 여러 상수를 한 줄에 선언할 수 있습니다.

Enum $eSunday = 1, $EMonday, $eTuesday ... 

$eMonday는 숫자를 저장하지 않아도 자동으로 2가 부여됩니다. $eTuesday에는 2가 들어갑니다.

Step 키워드를 써서 증가되는 값을 조절할 수 있습니다.

Enum Step 2 $eSunday, $eMonday, $eTuesday...

각 상수에는 차례대로 0, 2, 4 ,... 으로 값이 부여됩니다. 2 대신 -2를 지정하면 0, -2, -4 ...로 정의됩니다.

Step에 곱셈기호 *를 사용하면 배수로 상수의 값을 지정할 수 있습니다.

Enum Step *2 $eSunday, $eMonday...

순차적으로 값이 1, 2, 4, 8...로 상수 값이 부여됩니다.



## 11. 변수의 범위

함수 안에서 Local로 선언된 변수는 함수 안에서만 유효합니다. 함수 안에서 Global로 선언된 변수는 함수 밖에서도 유효합니다. 함수 밖에서 선언된 Local은 사실상 Global과 같습니다. 함수 밖에서 선언된 변수는 해당 파일 전체에서 사용 가능합니다.

Dim으로 변수가 선언될 때 함수 밖에서는 Global로 선언되고 함수 안에서는 Local로 선언됩니다. 이외에 Static도 있습니다. 이것은 함수 부분에서 설명하겠습니다.

변수 이름 짓는 방법에 변수의 범위를 추가할 수 있습니다. 만약 Global로 선언된 변수라면 $뒤에 g_를 붙입니다.

Global $g_sName = "AutoIt"

만약 Local이라면 $ 뒤에 g_를 붙이지 않습니다. 우리는 이것을 통해 변수의 적용 범위와 변수의 종류와 변수의 이름을 모두 알 수 있습니다.



## 12. 배열(arrays)

배열은 여러 개의 변수를 저장할 수 있는 상자입니다. 배열은 이름처럼 순서가 중요합니다. 배열은 순서를 가지고 있기 때문에 처리 속도가 빠릅니다. 다만 무조건 순서대로 일을 처리해 나가야만 합니다. 

또 배열에는 1차원 배열, 2차원 배열, n차원 배열을 만들 수 있습니다. 배열의 차원은 배열을 선언할 때 결정됩니다. 뒤에 상세하게 다루겠습니다.

배열에 저장될 데이터의 숫자는 정해져 있습니다. 이것을 배열의 크기라 불러도 좋습니다. 배열은 다음과 같이 선언합니다.

Local $aNames[5]

원소가 다섯 개인 1차원 배열입니다. 배열을 선언할 때에는 Local, Global 키워드를 반드시 사용해야 합니다.

배열을 선언하면서 동시에 원소를 초기화 할 수 있습니다.

Local $aNames[3] = ["AutoIt", "Java", "Python"]

원소를 초기화 하는 경우 원소의 갯수는 생략 가능합니다.

Local $aNames[] = ["AutoIt", "Java", "Python"]

Local $aNames = ["AutoIt", "Java", "Python"]

다차원 배열은 다음과 같이 선언합니다.

Local $aInfo[3][2]

이것은 2차원 배열을 선언한 것입니다. 초기화하는 방법은 다음과 같습니다.

Local $aInfo[3][2] = [["대한민국", "서울"], ["일본", "도쿄"], ["중국""베이징"]]

배열 속에 들어 있는 원소(elements)에는 번호가  부여됩니다. 이 번호를 가지고 배열 속의 원소에 접근할 수 있습니다. 한 반에 학생 숫자가 20명이라면 이름은 달라도 학생들에게 번호를 부여하여 이름을 몰라도 해당 학생을 호출할 수 있는 것과 같습니다.

Local $aNames[3] = ["AutoIt", "Python", "Java"]

$aNames[0] --> "AutoIt"

$aNames[2] --> "Java"

배열 내 첫번째 원소의 위치 번호는 0입니다. 0에서부터 오른쪽으로 가면서 1씩 증가합니다. 이것을 배열의 인덱스라고 합니다.

다차원 배열에서도 인덱스를 사용할 수 있습니다.

Local $aInfo[3][2] = [["대한민국", "서울"], ["일본", "도쿄"], ["중국""베이징"]]

$aInfo[1][0] --> "일본"

$aInfo[2][1] --> "베이징"

배열 속에는 무엇이든지 넣을 수 있습니다. 심지어 배열 속에 배열을 넣어도 됩니다. 배열은 64차원까지 가능하며, 배열 속의 원소의 최대 갯수는 2의 24승 개(16777216)입니다.

배열의 크기를 조절하려면 Redim 키워드를 사용할 수 있지만 UDF의 _Array 파일을 사용하는 것이 더 좋습니다.

Local $aLanguages[5] = ["오토잇", "파이썬", "자바스크립트", "C", "C++"]

Redim $aLanguages[8]

배열의 크기를 5에서 8로 늘였습니다. 새로 늘어난 원소에는 어떤 값도 들어 있지 않습니다.

Redim $aLanguages[3]

배열의 크기가 3으로 줄어 들면서 "C"와 "c++"는 없어졌습니다.

Redim 키워드보다 array.au3 파일을 포함(#Include)하시는 게 좋습니다. 예를 들어 보겠습니다.

### 07_array.au3

```autoit

#Include<array.au3>

Local $aLanguages[5] = ["AutoIt", "C", "C++", "Javascript", "Python"]
_ArrayDisplay($aLanguages, "$aLanguages 원소 보기")
_ArrayAdd($aLanguages, "Go")
_ArrayDisplay($aLanguages, "$aLanguages 원소 보기")
_ArrayDelete($aLanguages, 3)
_ArrayDisplay($aLanguages, "$aLanguages 원소 보기")

```

#Include는 오토잇 라이브러리를 코드 안에 포함시키는 역할을 합니다. array.au3이 담고 있는 함수들에 대한 설명은 오토잇 공식 메뉴얼의 "User Defined Functions" 항목을 참조하세요.

$aLanguages 배열에는 문자열 다섯 개가 들어 있습니다. _ArrayDisplay 함수는 array.au3에 포함된 함수인데, 배열 내의 원소를 확인할 수 있습니다. 2차원 배열까지 표시 가능합니다. 인덱스 0번부터 4번까지 다섯 가지 언어의 이름이 나타날 것입니다. ESC키를 다음 코드가 실행됩니다.

_ArrayAdd 역시 array.au3에 포함된 함수입니다. 배열의 끝에 원소 하나를 추가시킵니다. 여기에서는 "Go" 문자열을 추가했습니다. 이 결과를 _ArrayDisplay로 표시합니다.

_ArrayDelete는 배열 내의 원소를 삭제합니다. 두번째 재료 3는 인덱스를 말합니다. 인덱스3은 네번째 원소이니 "Javascript" 문자열이 삭제됩니다. _ArrayDisplay에서 확인해 보세요. 이렇게 명시적으로 원소를 추가하거나 삭제할 수 있기 때문에 Redim을 쓰는 것보다 좋습니다.



## 13. 맵(map)

맵 데이터는 사전 데이터와 유사하지만 접근성이 더 좋다고 합니다. 문제는 오토잇에서 맵 타입은 아직 정착되지 못했습니다. 오토잇의 구성 요소로 살아남을지 아닐지 아직은 모릅니다. 버그가 언제 어떻게 발생할지 모르니 이 점 유의해서 사용하세요. 하지만 편리하긴 편리합니다.

맵은 키(key)와 값(value)을 한쌍으로 하는 형식으로 데이터를 저장합니다. 키는 숫자와 문자열을 쓸 수 있는데 이때 사용하는 숫자는 배열의 인덱스와 완전히 다릅니다. 단지 "키"일 뿐 인덱스가 아닙니다. 또 MapKeys() 함수를 사용하면 맵의 모든 키를 확인할 수 있습니다. 맵은 다음과 같이 선언합니다.

Global $mScore[]

맵도 배열처럼 Local, Global 키워드를 반드시 사용해야 합니다.

"[]" 사이에 아무 값도 넣지 않으면 맵이 됩니다. 여기에 숫자를 넣으면 배열이 됩니다. 

Local $aScore[3] 

원소의 갯수를 쓰지 않더라도 배열 형식으로 초기화 하면 배열이 될 뿐 맵이 되지 않습니다. 맵은 절대로 초기화하지 마세요.

맵에 데이터를 추가하려면 다음과 같이 합니다.

Local $mInfo[]; 선언

$mInfo["대한민국"] = "서울"

$mInfo["일본"] = "도쿄"

$mInfo["china"] = "베이징"

추가한 데이터의 내용은 이렇게 찾아 볼 수 있습니다.

$sCity = $mInfo["대한민국"]

$sCity 변수에는 문자열 "서울"이 들어갑니다.

만약 키가 영문자로 되어 있다면 "." 연산자를 쓸 수 있습니다.

$sCity = $mInfo.china

$sCity에는 문자열 "베이징" 이 저장됩니다. 대괄호를 쓰지 않고 "."으로 china가 연결된 점을 주목하세요. 이 점이 일반적인 사전 데이터 타입과의 차이이며 서두에 사전보다 접근성이 좋다는 말이 바로 이 뜻입니다.



## 14. 매크로(Macro)

우리가 오토잇으로 프로그램을 만들 때 너무 너무 자주 사용하는 데이터들이 있습니다. 오토잇은 그것들을 매크로라는 이름으로 우리에게 편리하게 제공해 줍니다. 만약 올해 연도를 알고 싶으신가요? 골뱅이 "@" 뒤에 Year을 붙여 보세요. 그 자리에 올해 연도가 들어 갑니다. 바탕화면 폴더의 주소를 알고 싶으세요. @DesktopDir을 사용하세요. 교재 말미에 오토잇 매크로의 모든 항목을 실어 두었습니다. 참고하세요. 

매크로를 실제로 사용해 봅시다. 아래 코드를 입력하고 DateTime.au3으로 저장하세요. 

### 08_DateTime.au3

```autoit

MsgBox(0, "날짜 시각", @Year & "년 " & @Mon & "월 " & @MDay & "일 " & @Hour & "시 " & @Min & "분 " & @Sec & "초")

```

& 연산자는 문자열과 문자열을 결합해 줍니다. @Year에는 올해 연도가 들어 있고 그것을 "년 "이란 문자열과 결합하면 "2022년 "이 됩니다. 나머지도 이와 같습니다.

모든 매크로를 확인하려면 오토잇 공식 메뉴얼에 매크로 레퍼런스를 찾아 보세요.



## 15. 연산자(operators)

연산자라 하면 말이 너무 어렵습니다만, 덧셈, 뺄셈 같은 기능으로 생각하시면 편할 겁니다. 실제로 대표적인 연산자는 바로 4칙 연산 기호입니다.

- +: 덧셈
- -: 뺄셈
- *:  곱셈
- /: 나눗셈
- ^: 제곱

^은 제곱을 의미합니다. 3^3은 3의 3승으로 27입니다.

나누기를 하고 남은 나머지는 어떻게 구할까요? Mod를 활용하세요.

Mod(70, 6) -> 나머지 4

4칙 연산과 대입 연산자를 동시에 사용할 수도 있습니다. 복합산술연산자라 불리는 것이 바로 이것입니다.

$a = $a + 1

위 코드에서 $a는 두번 등장합니다. 이것을 이렇게 줄일 수 있습니다.

$a += 1

마찬가지로 -=, *=, /=을 모두 사용할 수 있습니다.

$a = $a -1 -> $-= 1

$a = $a * $b -> $a *= $b

$a = $a / $b -> $a /= $b

&는 문자열 결합 연산자입니다. 앞에서 소개해 드린 적 있습니다. 문자열과 무자열을 결합할 때 &를 사용하세요.

여러 줄에 걸쳐서 문자열 결합을 표현할 수 있습니다. 다음과 같이 언더바(_)를 사용하세요.

```autoit

$s = "개미네 집 주소 : " & @CRLF & _
"허리도 가늘군 만지면 부러지리"

```

@CRLF는  캐리지 리턴과 라인피드를 의미하는 매크로입니다. 다른 언어들에서 \r\n에 해당하는 것입니다. & 연산자 뒤에 언더바(_)를 넣으면 다음 줄에 문자열을 결합할 수 있습니다.

비교를 위한 연산자도 있습니다. 비교한 결과가 참이면 True를 반환하고 비교한 결과가 거짓이면 False를 반환합니다. 대표적인 비교 연산자는 부등호 기호입니다.

3 < 7

3은 7보다 작으므로 참입니다. 이 부등식은 True라는 결과로 변합니다. 

7 < 3

이 부등식은 거짓입니다. 따라서 False를 반환합니다.

비교 연산자는 다음과 같습니다.

- =: 두 항이 같은지를 비교합니다. 단 영어 문자열의 경우 대소문자 구별을 하지 않습니다. 
- ==: 같은지를 평가합니다. 문자열의 경우 대소문자를 엄격히 구별합니다.

1 = 1 -> True

1 = 2 -> False

'abc' = 'ABC' -> True

'abc' == 'ABC' -> False

'='은 대입연산자이기도 합니다. 혼동을 피하려면 '='은 대입연산자로 사용하시고 '=='만 비교 연산자로 사용하세요.

"같지 않다"는 <>으로 표시합니다.

"abc" <> "def" -> True

<> 연산자는 두 항이 같으면 False, 다르면 True를 반환합니다.

이외에 <, >, <=, >=도 비교 연산자로 사용합니다. 각각 보다 작다, 보다 크다, 작거나 같다, 크거나 같다를 의미합니다.

논리 연산자도 있습니다. And, Or, Not이 대표적입니다.

And는 두 항이 모두 True일 때 True를 반환합니다.

Or은 둘 중 하나가 True일 때 True를 반환합니다.

Not은 True를 False로 바꾸고, False를 True로 바꿉니다.

3 < 7 And 7 < 9

-> True And True

-> True

7 > 8 Or 2 < 3

-> False Or True

-> True

Not 0

-> True

숫자 0은 False입니다. "" 빈 문자열도 False입니다. Not은 False를 True로 바꿉니다.



## 16. 주석

코드를 적다보면 이 코드가 어떤 역할을 하던 것인지 깜빡 잊을 때가 있습니다. 코드의 작성 시기가 멀어질수록 이런 경향은 더욱 심해집니다. 그래서 코드는 아니지만 사용자를 위해 힌트를 남겨 놓을 필요가 있습니다. 그것을 주석이라고 부릅니다.

 오토잇에서는 한 줄 주석과 여러 줄 주석을 모두 지원합니다.

한줄 주석은 ";"을 쓰고 그 뒤에 힌트를 남깁니다. 오토잇은 ";" 오른쪽부터 그 줄 끝까지 한줄을 모두 주석으로 처리합니다. 예를 들면 다음과 같습니다.

; 남은 용돈 입력 받기

$Money = Input("용돈", "금액")

여러 줄 주석은 #CS로 시작해서 #CE로 끝납니다. 대체로 소스 코드 최상단에 이 프로그램의 정보를 간략히 기입해 두는 용도로 사용됩니다. 

#CS

파일 이름: MoneyBook.au3

작성자: 장창환

작성일시: 2022년 5월 1일

사용법: 오토잇 교육용이기 때문에 메모장에서 열어 보시면 됩니다.

#CE

 

## 17. 조건문

"누울 자리를 보고 다릴를 뻗어라"라는 말이 있습니다. 상황에 따라 알맞게 대처해야 한다는 것은 프로그래밍에서도 마찬가지입니다. 일상 생활에서 우리는 한번에 여러 가지를 놓고 고민할 때가 많습니다. "오늘 저녁에는 무엇을 먹을까"에 대해 짜장면, 짬뽕, 탕수육, 불고기 등등 한꺼번에 여러 가지를 고민할 수 있습니다. 하지만 컴퓨터는 동시에 여러 가지를 고민하지 못합니다. "사는야, 죽느냐, 그것이 문제로다"처럼 딱 두 가지 중 하나만 선택해야 합니다. 따라서 "무엇을 먹을까?"를 코딩으로 표현해 보면 다음과 같습니다.

지금 나는 짜장면을 먹고 싶은가?
그렇다면 중국집에 가자.
짜장이 아니고 뿔고기가 먹고 싶은가?
그렇다면 한식집에 가자.
불고기도 아니라면 초밥이 먹고 싶은가?
그렇다면 일식집에 가자.
먹고 싶은 것이 없는가?
집에 가서 라면이나 끓여 먹자.

이것을 오토잇에서는 다음과 같이 표현할 수 있습니다.

```autoit

If $Dinner = "짜장면" Then
GoTo("중국집")
ElseIf $Dinner = "불고기" Then
GoTo("한식집")
Else $Dinner = "초밥" Then 
GoTo("일식집")
Else
GoTo("우리집")
EndIf

```

조건문 가운데 가장 유명하고 가장 중심이 되는 것이 If ~ EndIf입니다.

If와 Then 사이에 들어가는 내용은 True, False로 평가됩니다. 결과가 True이면 Then 이하의 코드를 실행합니다. 만약 용돈이 5만원 보다 많으면 탕수육을 먹겠다고 생각해 봅시다.

If $Money > 50000 Then Eat("탕수육")

Then 이하의 문장이 딱 한 줄이면 이렇게 한 줄로 표현할 수도 있습니다. 만약 5만원 보다 적다면 짜장면을 먹는다고 하면 이렇게 쓸 수 있습니다.

```autoit

If $Money > 50000 Then
Eat("탕수육")
Else
eat("짜장면")
EndIf

```

프로그래밍 언어마다 조건문과 유사한 삼항 연산자를 지원합니다.  오토잇도 그렇습니다. "?" 앞에 조건을 넣고 True일 때, False일 때 할 행동은 ":"으로 표현합니다. 예를 들어 보겠습니다. 

### 09_if.au3

```autoit

$Money = InputBox("남은 용돈", "금액을 입력하세요.")
If $Money > 50000 Then
MsgBox(0, "결과", "저녁 메뉴는 탕수육입니다.")
Else
MsgBox(0, "결과", "저녁 메뉴는 짜장면입니다.")
EndIf

$food = $Money > 50000 ? "탕수육" : "짜장면"
MsgBox(0, "결과", "저녁 메뉴는 " & $food & "입니다.")

```

If 대신 Select, Switch 구문으로 표현할 수 있습니다. 

### 10_select.au3

```

$Money = InputBox("남은 용돈", "금액을 입력하세요.")

Select
Case $Money > 100000 
$Food = "팔보채"
Case $Money > 50000
$Food = "탕수육"
Case Else
$Food = "짜장면"
EndSelect
MsgBox(0, "결과", "저녁 식사 메뉴는 " & $Food & "입니다.")

$Name = InputBox("함께 식사할 사람", "이름")

Switch $Name
Case "갑돌이"
$Food = "탕수육"
Case "갑순이"
$Food = "팔보채"
Case Else
$Food = "짜장면"
EndSwitch
MsgBox(0, "결과", "함께 식사할 사람은 " & $Name & "님이고, 식사 메뉴는 " & $Food & "입니다.")

```

Select 구문은 If와 거의 동일합니다. Switch의 경우 조건 범위를 표현할 때 비교 연산자를 쓸 수 없다는 제한이 있습니다. 하지만 To를 이용하여 범위를 지정할 수 있습니다만 If, Select보다 자유롭지 못합니다. 예를 들어 다음과 같습니다.

```autoit

Switch $Money
Case 50001 To 100000
$Food = "탕수육"

```

파이썬(Python) 언어의 경우 조건문을 오로지 if로만 작성합니다. 그렇게 해도 문제가 없기 때문입니다. 여러분도 Select는 대략 이런 것이 있구나 하고 지나가세요. 대신 If는 열심히 공부하세요. Switch는 은근히 쏠쏠한 재미를 볼 수 있습니다. 간단한 형태의 Swithch는 종종 이 교재에서도 등장할 예정입니다.



## 18. 반복문

같은 일을 하루 종일 반복한다면 얼마나 지겨울까요? 게다가 같은 코드를 반복해서 타이핑하면 정말 힘들 것입니다. 모든 프로그래밍 언어에는 반복문이 있기 때문에 같은 작업을 반복하는 일을 줄일 수 있습니다. 오토잇에는 세 가지 반복이 있습니다.

첫번째는 For ~ To ~ Next인데, 횟수가 정해진 반복에 주로 사용합니다. 예를 들어 보겠습니다. 구구단을 표시하는데 무려 19단까지 표시한다고 생각해 봅시다.

2 * 2 = 4

2 * 3 = 6

2 * 4 = 8

...

19 * 19 = 361

이 지루한 작업을 반복하는 건 정말 힘든 일입니다. 이것을 For 구문을 사용하면 엄청 간단해 집니다.

```autoit

For $i=1 To 19
MsgBox(0, "결과", $i)
Next

```

최초 For 문은 임시 변수 $i에 2를 넣습니다. 그리고 그것을 MsgBox에 표시합니다. Next를 만나면 For로 되돌아 갑니다. 이때 $i의 값을 3으로 하나 커지게 합니다. $i의 값이 19에 도달하면 마지막 실행을 한 후 Next에서 반복이 종료됩니다.

For 안에  For를 또 넣어서 구구단을 완성할 수 있습니다. 아래 코드를 입력하고 9x9.au3으로 저장하세요.

### 11_9x9.au3

```autoit

Local $sResult = ""
For $i=2 To 19
For $j=2 To 19
$k = $i & "*" & $j & "=" & $i*$j & @CRLF
$sResult &= $k
Next
Next
ClipPut($sResult)

```

결과 분량이 많아서 MsgBox를 사용하지 않고 결과를 클립보드에 복사했습니다. 메모장을 열고 붙여 넣기를 하시면 결과를 확인할 수 있습니다.

구구단 프로그램에서 만약 짝수 구구단만 표시하려면 어떻게해야 할까요? 여러가지 방법이 있겠지만 Step 키워드를 사용하면 됩니다.

For $i=2 To 19 Step 2

위에서처럼 Step에 2를 지정하면 2, 4, 6, 8... 식으로 반복됩니다.

For는 확실히 반복횟수가 정해져 있습니다. 이와 달리 횟수를 정할 수도 있고 안 정할 수도 있는 반복도 있습니다. 바로 While 반복입니다. While의 전형적인 모습은 다음과 같습니다.

```autoit

$i = 2
While $i <= 19
MsgBox(0, "결과", $i)
$i += 1
WEnd

```

이 코드는 아래 코드와 동일한 결과를 냅니다.

```autoit

For $i=2 To 19
MsgBox(0, "결과", $i)
Next

```

While 키워드 뒤에는 조건식이 들어 있습니다. 이 조건을 만족하면 While 다음의 코드가 실행됩니다. WEnd를 만나면 코드는 다시 While로 돌아 옵니다. 이런 특징은 무한 반복을 가능하게 합니다.

```autoit

While 1
~
WEnd

```

숫자의 경우 0은 False이고 나머지는 True입니다. 따라서 While 1을 하면 무조건 무한 반복이 실행됩니다. 무한 반복을 종료시키려면 어떻게 해야 할까요? 그럴 때에는 ExitLoop 키워드를 사용하세요.  

### 12_while.au3

```autoit

While 1
$r = MsgBox(4, "무한반복", "계속 반복할까요?")
If $r == 7 Then ExitLoop
WEnd

```

반복을 강제로 종료할 때 ExitLoop를 쓴다면 불필요한 코드를 반복하지 않고 건너 뛰게 하는 ContinueLoop 키워드도 있습니다. 

### 14_continue.au3

```autoit

$i = 1
While 1
$r = MsgBox(2, "반복 횟수 " & $i, "무시를 누르면 반복 횟수가 증가하지 않습니다.")
If $r == 3 Then
ExitLoop
ElseIf $r == 5 Then 
ContinueLoop
EndIf
$i += 1
WEnd

```

중단 버튼을 누르면 ExitLoop가 실행되어 반복을 종료합니다.  다시 시도를 누르면 $i의 값을 1 증가시킵니다. 무시 버튼을 누르면 $i의 값을 증가하지 않고 곧바로 다시 While로 되돌아 갑니다.

무조건 딱 한번 실행한 다음에 While과 유사하게 동작시키는 반복도 있습니다. 

### 14_until.au3

```autoit

$i = 1
Do
$r = MsgBox(4, "반복 횟수" & $i, 반복을 중단하려면 아니오 버튼을 누르세요.")
$i += 1
Until $r == 7

```

오토잇이 실행될 때 Do 키워드를 만나면 아래 코드를 1회 무조건 실행합니다. Until 키워드 뒤에는 조건식이 있는데 이 조건을 만족하면 반복 실행을 멈춥니다. 조건식이 False가 될 때 다시 Do 키워드로 올라가서 다시 코드를 반복 실행합니다.

오토잇에는 For ~ In ~ Next라는 반복문도 있습니다. 이 반복은 객체 컬렉션을 대상으로 반복하는데 뒤에 예제를 가지고 설명하겠습니다. 여기에서는 건너 뛰겠습니다.

오토잇의 반복 구문은 딱 필요한 것만 모아 둔 것 같습니다. 익혀 두시면 두고 두고 유용하게 사용하실 겁니다.



## 19. 사용자 정의 함수

MsgBox처럼 오토잇이 제공하는 함수도 있지만 우리가 원하는 함수를 직접 만들 수도 있습니다. 만드는 방법은 다음과 같습니다.

```autoit

Func 함수이름(매개변수1, 매개변수2, ...)
함수 본문
EndFunc

```

함수는 Func와 EndFunc로 정의합니다. 함수이름은 영어로 시작해야 합니다. 매개변수는 사용해도 되고 안 해도 됩니다. 매개변수는 형식변수라고도 합니다. 어떤 재료가 투입될지 모르기 때문에 임시로 사용합니다. 매개변수는 해당 함수 안에서만 유효합니다.

### 15_hotkey.au3

```autoit

HotKeySet("!f", "Hello")

While 1
Sleep(100)
WEnd

Func Hello()
MsgBox(0, "안녕", "난 오토잇이야")
Exit
EndFunc

```

보통 스크립트 언어들의 경우 함수를 사용하려면 함수를 코드에 앞서 먼저 작성해 주어야 합니다. 하지만 오토잇은 그렇지 않습니다. 먼저 실행 코드를 적고 그 아래에 함수를 선언해도 됩니다.

HotKeySet 함수는 윈도우에 단축키를 추가할 때 사용합니다. 첫번째 매개변수는 단축키 조합을 나타냅니다. ^#은 WIN을 가리키고 ^은 CTRL을, !는 ALT를 +는 SHIFT를 가리킵니다. 

!f는 ALT+f 단축키입니다.

만약 While로 대기하지 않았다면 이 프로그램은 종료되고 말았을 겁니다. ALT+f를 눌러도 아무런 일도 일어나지 않았을 겁니다. 단축키가 눌릴 때까지 대기해야 하는데 이럴 때 While 1을 사용합니다.

Sleep 함수는 코드 실행을 일시정지시킬 때 사용합니다. Sleep을 넣지 않아도 상관 없습니다만 컴퓨터 자원의 불필요한 낭비를 줄이기 위해 Sleep을 사용했습니다.

HotKeySet의 두 번째 매개변수는 ALT+f가 눌린 후 동작할 함수를 지정한 것입니다. "Hello"는 Hello 함수를 실행하라는 의미입니다. 

Hello 함수 안에는 두 줄이 들어 있습니다. 첫 번째 줄은 인사말을 표시하는 MsgBox를 띄우는 것이고 두번째 줄은 프로그램을 종료하라는 키워드입니다. 오토잇은 Exit를 만나면 곧바로 프로그램을 종료합니다. 만약 이 코드를 넣지 않으면 While로 인해 이 프로그램은 무한 반복 무한 대기를 할 것입니다.

단, 시스템 트레이이ㅔ서 프로그램을 종료시킬 수 있습니다.

함수는 매개변수와 반환의 유무에 따라 네 가지로 구분될 수 있습니다.

매개변수도 없고 반환도 없는 함수

방금 위에서 만들어 봤지요.

매개변수만 있고 반환은 없는 함수, 매개변수는 없지만 반환은 있는 함수, 둘 다 있는 함수가 그것입니다. 어떤 함수가 필요할지는 천천히 생각해서 만들어 보시면 됩니다.

함수의 결과를 함수 밖으로 꺼낼 수 있습니다. 그것을 반환(Return)이라고 합니다. 매개변수로 넣고 Return으로 되돌려 받는 것입니다.

다음 함수는 어떤 일을 할까요? 코드를 입력하고 return.au3으로 저장하세요.

### 16_return.au3

```autoit

Func f($a, $b)
Return $a+$b
EndFunc

$r = f(3, 10)
MsgBox(0, "결과", $r)

```

Return 키워드는 함수의 결과를 함수 밖으로 돌려주는 역할을 합니다. 위 예제에서 함수 f를 실행할 때 매개변수 $a에는 3, $b에는 10을 입력했습니다. 즉 함수에 3과 10을 투입한 것입니다. 그 결과를 Return으로 꺼내서 $r에 저장한 것입니다.

함수는 한번에 하나만 반환할 수 있습니다. 만약  여러 개를 반환하려면  배열에 담아서 반환하세요.

이 정도면 오토잇으로 유용한 프로그램을 만들 수 있습니다. 



## 20. MP3다이렉트컷에 단축키 추가하기

첫 도전 과제는 MP3다이렉트컷입니다. 시각장애인들이 MP3 파일을 간단하게 편집할 때 이 프로그램을 사용하지요. 다만 아쉬운 것은 현재 위치를 읽어 주지 않는다는 것입니다. 그래서 이 프로그램에서만 동작하는 단축키를 추가하면 좋겠습니다. Ctrl+Space를 누르면 현재 재생 위치를 알려 주게끔 해 봅시다. 프로그램의 동작 흐름은 대략 다음과 같습니다.

- 우리가 만든 au3을 실행하면 MP3DirectCut도 실행된다.
- HotKeySet 함수로 단축키를 만든다.
- Ctrl+Space를 누르면 현재 재생 위치를 알려 준다.
- MP3DirectCut 프로그램이 비활성화되면 단축키도 비활성화 된다.
- MP3DirectCut 프로그램이 종료되면 단축키 프로그램도 자동으로 종료된다.

실험용 MP3DirectCut.exe는 아래 링크에서 다운로드 받으세요.

<https://github.com/JangChangHwan/jangchanghwan.github.io/blob/master/_posts/mp3DirectCut.exe>

코드는 다음과 같습니다.

### 17_mp3dc.au3

```autoit

#RequireAdmin
#Include<StringConstants.au3>

Global $pMP3DC = Run("mp3DirectCut.exe")
Global $oTTS = ObjCreate("Sapi.SpVoice")

While 1
If Not ProcessExists($pMP3DC) Then Exit
If StringRight(WinGetTitle("[active]"), 12) == "mp3DirectCut" Then 
HotKeySet("^{space}", "ReportCurrentPosition")
Else
HotKeySet("^{space}", "")
EndIf
Sleep(10)
Wend

Func ReportCurrentPosition()
$sText = WinGetText("[active]")
$start = StringInStr($sText, "현재:")
$end = StringInStr($sText, ".", $STR_NOCASESENSE, 1, $start)
$nChars = $end - $start + 3
$sResult = StringMid($sText, $Start, $nChars)
$sResult = StringReplace($sResult, "'", "분 ")
$sResult = StringReplace($sResult, ".", "초 ")
$oTTS.Speak($sResult)
EndFunc

```

#RequireAdmin

#RequireAdmin은 #Include와 같이 프로그램을 실행하기 이전에 처리한다고 해서 전처리기라고 불립니다. #RequireAdmin은  오토잇이 OS에게 관리자 권한을 요청하라는 의미입니다. Run 함수를 사용할 때 관리자 권한이 아니면 실행되지 않는 경우가 있습니다. 기왕이면 오토잇 소스 작성을 시작할 때 무조건 이 지시자(directives)를 사용하세요. 

몇 가지 대표적인 지시자를 열거해 봅니다.

- #CS, #CE : 주석 블럭을 시작하고 끝냅니다. 오토잇은 이 주석을 코드 실행에서 제외시킵니다.
- #Include-Once : 하나의 파일이 여러번 #Include로 읽어 들이더라도 한번만 포함되도록 합니다. 주로 라이브러리들은 이 지시자로 시작합니다.
- #NoTrayIcon : 이 지시자가 없으면 오토잇은 자동으로 트레이 영역에 오토잇 프로그램을 제어할 수 있는 아이콘을 추가합니다. 이 지시자가 들어가면 트레이 영역에 아이콘을 만들지 않습니다.
- #RequireAdmin : 앞 서 설명드렸습니다.
- #OnAutoItStartRegister : 오토잇이 시작될 때 호출하는 함수를 지정할 수 있습니다.
- #Pregma : 컴파일 방법을 지정합니다.

상세한 사용법은 예제 코드들 안에서 설명하겠습니다.

#Include<StringConstants.au3>

문자열 처리에 관련된 상수들이 정의된 파일을 가져와서 이 소스파일에 포함시킵니다.

Global $pMP3DC = Run("mp3DirectCut.exe")

MP3DirectCut를 실행합니다. 실행된 프로세스 아이디는 $pMP3DC에 저장됩니다.

Global $oTTS = ObjCreate("Sapi.SpVoice")

S-API TTS엔진을 준비시킵니다.

If Not ProcessExists($pMP3DC) Then Exit

ProcessExists는 프로세스가 존재하는지 아닌지를 확인하는 함수입니다. 파일이름으로 검사할 수 도 있습니다. 만약 메모장이 실행되어 있는지를 알고 싶다면 다음과 같이 합니다.

ProcessExists("notepad.exe")

그러나 프로그램 이름으로 검사하는 경우 메모장이 여러 개 실행된 경우라면 내가 원하는 메모장이 어느 것인지 구분할 수 없습니다. 그런데 프로세스 아이디는 프로세스마다 딱 한 개만 존재합니다. 위에서 Run 함수의 실행 결과 프로세스 아이디가 $pMP3DC에 저장되었습니다. 이 아이디로 Run으로 실행된 MP3DirectCut 프로세스만 꼭 집어 내서 여전히 실행 중인지 아닌지를 검사할 수 있습니다.

프로세스가 존재하지 않으면 False가 반환될 것입니다. False 앞에 Not가 붙어 있으므로 False는 True로 바뀌면서 Then 다음의 내용이 실행됩니다. 즉 이 오토잇 프로그램이 종료되는 것입니다. 이 코드는 MP3DirectCut가 종료되면 오토잇 프로그램도 자동으로 종료되도록 만듭니다.

If StringRight(WinGetTitle("[active]"), 12) == "mp3DirectCut" Then 

이 코드와 동일한 내용은 메모장 넋두리 프로그램에서 설명했습니다.

HotKeySet("^{space}", "ReportCurrentPosition")

HotKeySet은 앞에서 한번 소개한 적이 있었습니다. HotKeySet의 첫번째 매개변수는 단축키를 의미합니다. 이 단축키는 Send 함수에서 사용하는 바로 그것입니다. 대표적인 키들을 소개합니다.

- ^: Ctrl
- !: Alt
+: Shift
- # : Win
- {space}: 스페이스
- {enter}: 엔터
- {appskey}: 팝업키

상세한 것은 오토잇 도움말 부록 중 Send Key List를 참고하세요.

HotKeySet의 두번째 문자열은 단축키를 눌렀을 때 실행될 함수이름입니다. 반드시 문자열로 써야 합니다.

HotKeySet("^{space}", "")

만약 두번째 매개변수로 빈 문자열 ""을 입력하면 이 단축키가 해제됩니다.

이 코드에서 If 코드 블록의 역할은 MP3DirectCut이 활성화 되면 단축키도 같이 활성화 시키고 MP3DirectCut이 비활성화 되면 단축키도 비활성화 시키는 것입니다. Ctrl+Space 단축키는 다른 프로그램에서 동작하면 안되기 때문입니다. 예를 들어 파일탐색기에서 Ctrl+Space는 파일을 다중 선택할 때 사용됩니다. 따라서 Ctrl+Space는 반드시 MP3DirectCut에서만 동작해야 합니다.

Func ReportCurrentPosition()

사용자 정의 함수를 선언한 코드입니다.

$sText = WinGetText("[active]")

현재 활성화된 윈도우에서 텍스트를 추출한 후 $sText에 저장했습니다. WinGetTitle와 비교해 보세요.

$start = StringInStr($sText, "현재:")

윈도우 텍스트 중 "현재:"라는 부분 문자열이 있는지 검사합니다. 만약 부분 문자열이 있다면 그 위치를 반환해서 $start에 저장합니다.

오토잇에서 문자열 위치(인덱스)는 1부터 시작합니다. 1이면 첫번째 글자가 "현"으로 시작할 것입니다.

이 코드부터 StringMid 함수를 사용한 줄까지는 $sText 중 현재 위치가 나타난 부분 문자열을 뽑아 내기위한 코드입니다. 사실 정규표현식을 사용하면 한 줄로 해결 가능합니다만, 정규표현식에 앞서 문자열 관련 함수들을 먼저 학습하는 게 좋습니다.

$end = StringInStr($sText, ".", $STR_NoCaseSense, 1, $start)

StringInStr 함수를 좀 더 세밀하게 사용한 코드입니다. StringInStr의 매개변수는 다음과 같습니다.

- 첫번째 매개변수: 전체 문자열
- 두번째 매개변수: 검사할 부분 문자열
- 세번째 매개변수: 검사 옵션입니다. 여기에서는 대소문자 구분을 하지 않는 옵션을 설정했습니다. 해당 상수는 StringConstants.au3에 기록되어 있습니다.
- 네번째 매개변수: 부분 문자열의 검색 방향과 횟수를 지정합니다. 양수는 왼쪽에서 검색하고 음수는 오른쪽에서 검색합니다. 1은 첫번째 검사 결과를 반환하고 2는 두번째, 3은 세번째 검색 결과를 반환합니다. 여기에서 1은 왼쪽부터 검색하고 첫번째 검색 결과를 반환하는 것입니다.
- 다섯번째 매개변수: 검사를 시작할 인덱스입니다. 만약 이 수가 5라면 다섯번째 글자부터 검색하기 시작합니다. $start에는 "현재:"의 "현"에 해당하는 인덱스입니다. 따라서 "."은 "현" 다음부터 검색해서 첫번째로 나타나는 "."을 $end에 저장하게 될 것입니다.

$nChars = $end - $start + 3

$start에는 "현"의 위치가 들어 있고 $end에는 "."의 위치가 들어 있습니다. 이것을 토대로 현재 위치 부분 문자열의 길이를 알 수 있습니다. "." 다음에 숫자 두 개가 더 있기 때문에 3을 더해 줍니다. 결과는 $nChars에 들어 갑니다. 

$sResult = StringMid($sText, $Start, $nChars)

StringMid 함수는 문자열 중간부터 부분 문자열을 가져옵니다. 첫번째 매개변수는 전체 문자열이고 두번째 매개변수는 부분문자열이 시작되는 인덱스이며, 세번째 매개변수는 시작 인덱스부터 가져올 글자의 갯수입니다.

$sResult = StringReplace($sResult, "'", "분 ")

$sResult = StringReplace($sResult, ".", "초 ")

StringReplace는 전체 문자열에서 특정한 문자열을 다른 문자열로 대치하는 함수입니다. 메모장에서 바꾸기를 하는 것과 같습니다.

$oTTS.Speak($sResult)

결과를 TTS로 음성 출력합니다.

자! MP3DirectCut을 .au3 파일이 있는 곳에 복사해 두시고 실행해 봅시다. 정말 현재 위치를 알려 주나요? 이 정도 코드가 쉽다고 느껴진다면 이제 한 단계 더 업그레이드 해 봅시다.



--- To be continued ---
